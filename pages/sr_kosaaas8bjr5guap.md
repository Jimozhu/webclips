---
title: Go 泛型介绍 [译]
date: 2022-03-26T11:00:01+08:00
draft: false
categories: [dev]
tags: [dev, golang]
---
> 原文地址 [www.tuicool.com](https://www.tuicool.com/articles/QJ3A7rV)

本文永久链接 – [https://tonybai.com/2022/03/25/intro-generics](https://tonybai.com/2022/03/25/intro-generics)

Go 核心团队在官博上发布了一篇名为 [《An Introduction To Generics》](https://go.dev/blog/intro-generics) 的文章，该文章基于 Robert Griesemer 和 Ian Lance Taylor 在 2021 年 GopherCon 大会上的演讲，这是 [Go 团队发布 Go 1.18 版本](https://mp.weixin.qq.com/s/RY4tIxuKFIem8z9QHgsCPA) 后官博发表的首篇有关 Go 泛型的文章，值得大家认真阅读，这里将全文做一下翻译，供大家参考。

### 简介

这篇博文是基于我们在 [2021 年 GopherCon 上的演讲](https://youtu.be/Pa_e9EeCdy8) 。

Go 1.18 版本增加了对泛型的支持。泛型是我们自 Go 语言开源以来对 Go 做出的一次最大的变更。在这篇文章中，我们将介绍这个新的语言特性。我们不会面面俱到的讲解泛型语法特性的所有细节，但我们会介绍所有我们认为重要的内容。关于 Go 泛型语法更为详细的描述以及示例，请看 [Go 泛型的提案文件](https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md) 。关于语言变化的更精确描述，请看更新后的 [Go 语言规范](https://go.dev/ref/spec) 。(请注意，实际的 1.18 实现对提案文件所允许的内容施加了一些限制；现阶段， [更新后的语言规范](https://go.dev/ref/spec) 应该是更准确的。未来的 Go 版本可能会取消 Go 1.18 实现中的某些限制）。

泛型是一种编程范式，这种范式与特定的类型无关，泛型允许在函数和类型的实现中使用某个类型集合中的任何一种类型。

泛型在 Go 语言中增加了三个新的重要内容：

- 函数和类型新增对 \*\* 类型形参 (type parameters) 的支持。
- 将接口类型定义为类型集合，包括没有方法的接口类型。
- 支持类型推导，大多数情况下，调用泛型函数时可省略类型实参 (type arguments)。

### 类型形参 (Type Parameters)

现在，函数和类型被允许拥有类型形参 (Type Parameters)。一个类型形参列表看起来和普通的函数形参列表一样，只是它使用的是方括号而不是小括号。

为了说明这一点，让我们先看一个用于浮点值的基本的、非泛型的 Min 函数：

```
func Min(x, y float64) float64 {
    if x < y {
        return x
    }
    return y
}
```

我们可以通过添加一个类型形参列表来使这个函数泛型化，以使其适用于不同的类型。在这个例子中，我们添加了一个仅有一个类型形参 T 的类型形参列表，并用 T 替换 float64 的使用。

```
func GMin[T constraints.Ordered](x, y T) T {
    if x < y {
        return x
    }
    return y
}
```

现在我们可以像下面代码那样，用一个类型实参 (Type argument) 来调用这个函数了：

```
x := GMin[int](2, 3)
```

向 GMin 函数提供类型实参，在本例中是 int，称为 **实例化 (instantiation)** 。实例化分两步进行。首先，编译器在整个泛型函数或泛型类型中把所有的类型形参替换成它们各自的类型实参。第二，编译器验证每个类型实参是否满足各自的约束条件。我们很快就会知道这意味着什么，但是如果第二步失败，实例化就会失败，程序也会无效。

在成功的实例化之后，我们就有一个非泛型的函数了，它可以像其他普通函数一样被调用。比如下面的代码：

```
fmin := GMin[float64]
m := fmin(2.71, 3.14)
```

GMin[float64] 的实例化产生了一个与 Min 函数等效的函数，我们可以在函数调用中使用它。

类型参数也可以与类型一起使用。

```
type Tree[T interface{}] struct {
    left, right *Tree[T]
    value       T
}

func (t *Tree[T]) Lookup(x T) *Tree[T] { ... }

var stringTree Tree[string]
```

在上面这个例子中，泛型类型 Tree 存储了类型参数 T 的值。泛型类型也可以有方法，比如本例中的 Lookup。为了使用一个泛型类型，它必须被实例化；Tree[string] 是一个用类型实参 string 来实例化 Tree 的例子。

### 类型集合 (Type sets)

让我们深入了解一下可以用来实例化一个类型形参的类型实参。

一个普通函数的每个值形参 (译注：value parameter，相对于类型形参 type parameter) 都有一个对应的类型；该类型定义了一组值。例如，上面的非泛型函数 Min 有一个 float64 类型的形参，那么函数 Min 允许的实参值集合就是可以由 float64 类型表示的浮点值集合。

同样地，类型形参列表中的每个类型形参都有一个类型。因为类型形参本身就是一个类型，所以类型形参的类型定义了类型的集合。这种元类型 (meta-type) 被称为 **类型约束 (type constraint)** 。

在泛型函数 GMin 中，类型约束是从 [constraints 包](https://golang.org/x/exp/constraints) 中导入的。Ordered 约束描述了所有类型的集合，这些类型的值可以被排序，或者换句话说，用 < 运算符（或 <= ,> , 等）进行比较。该约束确保只有具有可排序值的类型才能被传递给 GMin。这也意味着在 GMin 的函数体中，该类型参数的值可以被用于 < 运算符的比较。

在 Go 中，类型约束必须是接口。也就是说，一个接口类型可以作为一个值类型使用，也可以作为一个元类型 (meta-type) 使用。接口定义了方法，所以显然我们可以使用要求某些方法存在的类型约束。但是 constraints.Ordered 也是一个接口类型，而且 < 操作符也不是一个方法。

为了使其发挥作用，我们 **以一种新的方式来看待接口** 。

直到最近 (译注：该演讲发生在 Go 1.18 发布之前，这里的最近是 Go 1.18 发布之前的某个时间点)，Go 规范说， **一个接口定义了一个方法集合** ，大略就是接口中列举的方法集合。任何实现了所有这些方法的类型都实现了该接口。

![](https://simpleread.oss-cn-guangzhou.aliyuncs.com/sr_kosaaas8bjr5guap/0aff5b02.png)

但另一种看法是，接口定义了一个类型集合 (type set)，即实现这些方法的类型。从这个角度来看，任何属于接口定义的类型集合中的元素的类型都实现了该接口。

![](https://simpleread.oss-cn-guangzhou.aliyuncs.com/sr_kosaaas8bjr5guap/c51d8737.png)

这 **两种观点殊途同归** 。对于每个方法集合，我们可以想象出实现这些方法的类型组成的类型集合，这就是接口所定义的类型集合。

不过对于我们的目的来说，类型集合的观点比方法集合的观点更有优势： 我们可以明确地将类型添加到集合中，从而以新的方式控制类型集合 。

我们已经扩展了接口类型的语法，以使其发挥作用。例如，interface{int|string|bool} 定义了包含 int、string 和 bool 的类型集合。

![](https://simpleread.oss-cn-guangzhou.aliyuncs.com/sr_kosaaas8bjr5guap/e27988d2.png)

另一种说法是，这个接口只被 int、string 或 bool 所满足。

现在我们来看看 contraints.Ordered 的实际定义。

```
type Ordered interface {
    Integer|Float|~string
}
```

这个声明说的是，Ordered 接口是所有整数、浮点和字符串类型的集合。 **竖线** 表达了类型（或者说这里是类型集合）的联合 (union)。Integer 和 Float 是接口类型，在 constraints 包中也有类似的定义。注意，Ordered 接口没有定义任何方法。

对于类型约束，我们通常不关心某一个特定的类型，比如字符串；我们对所有的字符串类型感兴趣。这就是~ 标记的作用。表达式~ string 意味着底层类型 (underlying type) 为 string 的所有类型的集合。这包括 string 类型本身，以及所有用类似 type MyString string 声明的类型。

当然，我们仍然想在接口中指定方法，而且我们想向后兼容。在 Go 1.18 中，一个接口可以像以前一样包含方法和嵌入接口，但它也可以嵌入非接口类型、联合体 (union) 和底层类型的集合。

当作为类型约束使用时，由接口定义的类型集合准确地指定了允许作为各自类型形参的类型实参的类型。在一个泛型函数体中，如果一个操作数的类型是带有约束 C 的类型形参 P，那么如果操作被 C 的类型集合中的所有类型所允许，那么这些操作就是允许的（目前这里有一些实现限制，但是普通代码不太可能遇到这些限制）。

用作约束的接口可以被赋予名称（比如 Ordered），也可以是内联到类型形参列表中的接口字面值，比如下面代码：

```
[S interface{~[]E}, E interface{}]
```

这里 S 必须是一个切片类型，切片的元素类型可以是任何类型。

因为这是一种常见的情况，所以对于处于约束位置的接口，用作包围的 interface{} 可以被省略，我们可以简单地写成下面这样：

```
[S ~[]E, E interface{}]
```

因为空接口在类型形参列表中很常见，在普通的 Go 代码中也是如此，Go 1.18 引入了一个 [新的预声明的标识符 any 作为空接口类型的别名](https://mp.weixin.qq.com/s/9iNYCpDYWWINctqwYLtDPA) 。这样一来，我们就得到了下面这段符合惯用法的代码：

```
[S ~[]E, E any]
```

作为类型集合的接口是一种强大的新机制，是使类型约束在 Go 中发挥作用的关键。目前，使用新语法形式的接口只能作为约束使用。但不难想象，显式指明类型约束的接口在一般情况下是多么有用。

### 类型推导 (Type inference)

最后一个主要的语言新特性是类型推导。在某些方面，这是语言最复杂的变化，但它很重要，因为它让人们在编写调用泛型函数的代码时使用一种更为自然的风格。

#### 函数实参类型推导 (Function argument type inference)

有了类型形参，我们就需要传递类型实参，这可能使代码变得冗长。回到我们的泛型 GMin 函数：

```
func GMin[T constraints.Ordered](x, y T) T { ... }
```

类型形参 T 用于指定普通 non-type 参数 x 和 y 的类型。正如我们前面所看到的，我们可以用一个显式类型实参来调用它：

```
var a, b, m float64
m = GMin[float64](a, b) // 显式传递类型实参
```

在许多情况下，编译器可以从普通参数中推导出 T 的类型实参。这使得代码更短，同时保持清晰：

```
var a, b, m float64
m = GMin(a, b) // 没有传入类型实参
```

其原理是将实际参数 a 和 b 的类型与形式参数 x 和 y 的类型相匹配。

这种从函数的实参类型推导出类型实参的推导方式，被称为 **函数实参类型推导** 。

函数实参类型推导只适用于在函数参数中使用的类型形参的情况，不适用于只在函数返回值中使用的类型形参或只在函数主体中使用的类型形参的情况。例如，它不适用于像 MakeT T any T 这样的函数，它只在返回值参数列表中使用了类型形参 T。

#### 约束类型推导 (Constraint type inference)

Go 语言还支持另一种类型推导，即约束类型推导。为了说明这类推导，让我们从下面这个缩放整数切片的例子开始：

```
// Scale返回一个s的副本，每个元素都乘以c。
// 这个实现有一个问题，正如我们将看到的。
func Scale[E constraints.Integer](s []E, c E) []E {
    r := make([]E, len(s))
    for i, v := range s {
        r[i] = v * c
    }
    return r
}
```

这是一个泛型函数，适用于任何整数类型的切片。

现在，假设我们有一个多维的 Point 类型，其中每个 Point 只是一个表示该点坐标的整数列表。自然，这个类型会有一些方法。

```
type Point []int32

func (p Point) String() string {
    // 实现细节不重要
}
```

有时我们想对一个点进行缩放。因为一个点是一个整数切片，我们可以使用我们之前写的 Scale 函数。

```
// ScaleAndPrint将一个点加倍并打印出来。
func ScaleAndPrint(p Point) {
    r := Scale(p, 2)
    fmt.Println(r.String()) // 无法通过编译
}
```

不幸的是，这无法通过编译，编译器将给出 r.String undefined (type []int32 has no field or method String) 这样的错误。

问题在于 Scale 函数返回一个 []E 类型的值，其中 E 是参数切片的元素类型。当我们用一个 Point 类型的值调用 Scale 时，它的底层类型是 []int32，我们得到的是一个 []int32 类型的值，而不是 Point 类型。这是由泛型代码的写法决定的，但这并不是我们想要的。

为了解决这个问题，我们必须改变 Scale 函数，使其使用一个类型参数来表示分片类型。

```
// Scale returns a copy of s with each element multiplied by c.
func Scale[S ~[]E, E constraints.Integer](s S, c E) S {
    r := make(S, len(s))
    for i, v := range s {
        r[i] = v * c
    }
    return r
}
```

我们引入了一个新的类型参数 S，用于表示切片参数的类型。我们对它进行了约束，使其底层类型是 S 而不是 []E，返回值类型现在是 S。由于 E 被约束为一个整数，其效果与之前一样：第一个参数必须是某个整数类型的切片。该函数主体的唯一变化是，现在我们在调用 make 时传递 S，而不是 []E。

如果我们用一个普通的切片来调用它，新函数的作用和以前一样，但是如果我们用 Point 类型来调用它，我们现在得到一个 Point 类型的值。这就是我们想要的。有了这个版本的 Scale，早先的 ScaleAndPrint 函数将如我们所期望的那样编译和运行。

但你可能会问：为什么调用 Scale 时不显式传递类型实参也可以呢？也就是说，为什么我们可以写 Scale(p, 2)，没有类型实参，而不是必须写 Scale[Point, int32](p, 2)？我们的新 Scale 函数有两个类型参数，S 和 E。在不传递任何类型实参的 Scale 调用中，上面描述的 **函数实参类型推导** 让编译器推导出 s 的类型实参是 Point。但该函数还有另外一个类型形参 E， 编译器推导出 E 的类型实参是切片的元素类型的过程被称为约束类型推导 。

约束类型推导是从类型形参约束中推导出类型实参。当一个类型形参的约束的定义中包含另一个类型形参时，它就会被使用。当这些类型形参中的一个的类型实参是已知的时候，该约束被用来推导另一个类型形参的类型实参。

约束类型推导通用用于当一个约束对某些类型使用~ type 的形式时，该 type 是用其他类型形参写的。我们在 Scale 的例子中看到了这一点。S 是~[]E，~ 后面的类型 []E 用另一个类型形参 E 来写成的。如果我们知道 S 的类型实参，我们就可以推导出 E 的类型实参。S 是一个切片类型，而 E 是该切片的元素类型。

这只是对约束类型推导的一个介绍。完整的细节请参见 [提案文档文件](https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md) 或 [语言规范](https://go.dev/ref/spec) 。

#### 类型推导实践

类型推导的工作原理细节很复杂，但使用它并不复杂：类型推导要么成功要么失败。如果它成功了，类型实参可以被省略，调用泛型函数看起来与调用普通函数没有什么不同。如果类型推导失败，编译器会给出一个错误信息，在这些情况下，我们可以直接提供必要的类型实参。

在向语言添加类型推导时，我们试图在推导能力和复杂性之间取得平衡。我们想确保当编译器推导出类型时，这些类型永远不会令人惊讶。我们试图小心翼翼地站在未能推导出类型的一边，而不是站在推导出错误类型的一边。我们可能没有完全做到这一点，而且我们可能会在未来的版本中继续完善它。其效果是，更多的程序可以无需显式提供类型实参。今天不需要类型实参的程序，明天也不会需要。

### 小结

泛型是 1.18 中一个很大的新语言特性。这些新的语言变化需要大量的新代码，这些代码还没有在生产环境中进行过大量的测试。这只会随着越来越多的人编写和使用泛型代码而发生。我们相信这个功能实现得很好，质量很高。然而，与 Go 的大多数方面不同，我们无法用现实世界的经验来支持这一信念。因此，虽然我们鼓励在有意义的地方使用泛型，但在生产中部署泛型代码时，请使用适当的谨慎措施。
